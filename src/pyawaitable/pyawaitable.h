/*
 * PyAwaitable - Autogenerated distribution copy of version 2.0.0
 *
 * Docs: https://awaitable.zintensity.dev
 * Source: https://github.com/ZeroIntensity/pyawaitable
 */

#if !defined(PYAWAITABLE_VENDOR_H) && !defined(Py_LIMITED_API)
#define PYAWAITABLE_VENDOR_H
#define _PYAWAITABLE_VENDOR

#define PyAwaitable_MAJOR_VERSION 2
#define PyAwaitable_MINOR_VERSION 0
#define PyAwaitable_MICRO_VERSION 0
#define PyAwaitable_PATCH_VERSION PyAwaitable_MICRO_VERSION
#define PyAwaitable_MAGIC_NUMBER 200

#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include <Python.h>
#ifndef PYAWAITABLE_OPTIMIZE_H
#define PYAWAITABLE_OPTIMIZE_H

#if (defined(__GNUC__) && __GNUC__ >= 15) || defined(__clang__) && \
    __clang__ >= 13
#define PyAwaitable_MUSTTAIL [[clang::musttail]]
#else
#define PyAwaitable_MUSTTAIL
#endif

#if defined(__GNUC__) || defined(__clang__)
/* Called often */
#define PyAwaitable_HOT __attribute__((hot))
/* Depends only on input and memory state (i.e. makes no memory allocations */
#define PyAwaitable_PURE __attribute__((pure))
/* Depends only on inputs */
#define PyAwaitable_CONST __attribute__((const))
/* Called rarely */
#define PyAwaitable_COLD __attribute__((cold))
#else
#define PyAwaitable_HOT
#define PyAwaitable_PURE
#define PyAwaitable_CONST
#define PyAwaitable_COLD
#endif

#if defined(__GNUC__) || defined(__clang__)
#define PyAwaitable_UNLIKELY(x) (__builtin_expect(!!(x), false))
#define PyAwaitable_LIKELY(x) (__builtin_expect(!!(x), true))
#elif (defined(__cplusplus) && (__cplusplus >= 202002L)) || \
    (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
#define PyAwaitable_UNLIKELY(x) (x)[[unlikely]]
#define PyAwaitable_LIKELY(x) (x)[[likely]]
#else
#define PyAwaitable_UNLIKELY(x) (x)
#define PyAwaitable_LIKELY(x) (x)
#endif

#ifdef thread_local
#  define PyAwaitable_thread_local thread_local
#elif __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
#  define PyAwaitable_thread_local _Thread_local
#elif defined(_MSC_VER)  /* AKA NT_THREADS */
#  define PyAwaitable_thread_local __declspec(thread)
#elif defined(__GNUC__)  /* includes clang */
#  define PyAwaitable_thread_local __thread
# else
#error \
    "no thread-local storage classifier is available"
#endif
#endif

#ifndef PYAWAITABLE_DIST_H
#define PYAWAITABLE_DIST_H

#if PY_MINOR_VERSION < 9
#error \
    "Python 3.8 and older are no longer supported, please use Python 3.9 or newer."
#endif

#ifdef _PYAWAITABLE_VENDOR
#define _PyAwaitable_API(ret) static ret
#define _PyAwaitable_INTERNAL(ret) static ret
#define _PyAwaitable_INTERNAL_DATA(tp) static tp
#define _PyAwaitable_INTERNAL_DATA_DEF(tp) static tp
#else
/* These are for IDEs */
#define _PyAwaitable_API(ret) ret
#define _PyAwaitable_INTERNAL(ret) ret
#define _PyAwaitable_INTERNAL_DATA(tp) extern tp
#define _PyAwaitable_INTERNAL_DATA_DEF(tp) tp
#define PyAwaitable_MAGIC_NUMBER 0
#endif

#define _PyAwaitable_MANGLE(name) name
#define _PyAwaitable_NO_MANGLE(name) name

#endif

#ifndef PYAWAITABLE_ARRAY_H
#define PYAWAITABLE_ARRAY_H



#define ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE 16

/*
 * Deallocator for items on a __PyAwaitable_Mangled_pyawaitable_array structure. A NULL pointer
 * will never be given to the deallocator.
 */
typedef void (*_PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_array_deallocator))(void *);

/*
 * Internal only dynamic array for PyAwaitable.
 */
typedef struct {
    /*
     * The actual items in the dynamic array.
     * Don't access this field publicly to get
     * items--use __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM() instead.
     */
    void **items;
    /*
     * The length of the actual items array allocation.
     */
    Py_ssize_t capacity;
    /*
     * The number of items in the array.
     * Don't use this field publicly--use __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH()
     */
    Py_ssize_t length;
    /*
     * The deallocator, set by one of the initializer functions.
     * This may be NULL.
     */
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_array);


/* Zero out the array */
static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ZERO(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    array->deallocator = NULL;
    array->items = NULL;
    array->length = 0;
    array->capacity = 0;
}

static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    assert(array->items != NULL);
}

static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    // Ensure the index is valid
    assert(index < array->length);
    assert(index >= 0);
}

/*
 * Initialize a dynamic array with an initial size and deallocator.
 *
 * If the deallocator is NULL, then nothing happens to items upon
 * removal and upon array clearing.
 *
 * Returns -1 upon failure, 0 otherwise.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_init_with_size(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
);

/*
 * Append to the array.
 *
 * Returns -1 upon failure, 0 otherwise.
 * If this fails, the deallocator is not ran on the item.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(__PyAwaitable_Mangled_pyawaitable_array * array, void *item);

/*
 * Insert an item at the target index. The index
 * must currently be a valid index in the array.
 *
 * Returns -1 upon failure, 0 otherwise.
 * If this fails, the deallocator is not ran on the item.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_insert(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    Py_ssize_t index,
    void *item
);

/* Remove all items from the array. */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(__PyAwaitable_Mangled_pyawaitable_array * array);

/*
 * Clear all the fields on the array.
 *
 * Note that this does *not* free the actual dynamic array
 * structure--use __PyAwaitable_Mangled_pyawaitable_array_Free() for that.
 *
 * It's safe to call __PyAwaitable_Mangled_pyawaitable_array_init() or init_with_size() again
 * on the array after calling this.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(__PyAwaitable_Mangled_pyawaitable_array * array);

/*
 * Set a value at index in the array.
 *
 * If an item already exists at the target index, the deallocator
 * is called on it, if the array has one set.
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index, void *item);

/*
 * Remove the item at the index, and call the deallocator on it (if the array
 * has one set).
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_remove(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index);

/*
 * Remove the item at the index *without* deallocating it, and
 * return the item.
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void *)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index);

/*
 * Clear all the fields on a dynamic array, and then
 * free the dynamic array structure itself.
 *
 * The array must have been created by __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new()
 */
static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(array);
    PyMem_RawFree(array);
}

/*
 * Equivalent to __PyAwaitable_Mangled_pyawaitable_array_init_with_size() with a default size of 16.
 *
 * Returns -1 upon failure, 0 otherwise.
 */
static inline int
__PyAwaitable_Mangled_pyawaitable_array_init(
    __PyAwaitable_Mangled_pyawaitable_array *array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator
)
{
    return __PyAwaitable_Mangled_pyawaitable_array_init_with_size(
        array,
        deallocator,
        ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE
    );
}

/*
 * Allocate and create a new dynamic array on the heap.
 *
 * The returned pointer should be freed with __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free()
 * If this function fails, it returns NULL.
 */
static inline __PyAwaitable_Mangled_pyawaitable_array *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size(
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
)
{
    __PyAwaitable_Mangled_pyawaitable_array *array = PyMem_Malloc(sizeof(__PyAwaitable_Mangled_pyawaitable_array));
    if (PyAwaitable_UNLIKELY(array == NULL)) {
        return NULL;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init_with_size(array, deallocator, initial) < 0) {
        PyMem_Free(array);
        return NULL;
    }

    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array); // Sanity check
    return array;
}

/*
 * Equivalent to __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size() with a size of 16.
 *
 * The returned array must be freed with __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free().
 * Returns NULL on failure.
 */
static inline __PyAwaitable_Mangled_pyawaitable_array *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new(__PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator)
{
    return __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size(
        deallocator,
        ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE
    );
}

/*
 * Get an item from the array. This cannot fail.
 *
 * If the index is not valid, this is undefined behavior.
 */
static inline void *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    return array->items[index];
}

/*
 * Get the length of the array. This cannot fail.
 */
static inline Py_ssize_t PyAwaitable_PURE
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    return array->length;
}

/*
 * Pop the item at the end the array.
 * This function cannot fail.
 */
static inline void *
__PyAwaitable_Static___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop_top(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    return __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(array, __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array) - 1);
}

#endif

#ifndef PYAWAITABLE_BACKPORT_H
#define PYAWAITABLE_BACKPORT_H


#ifndef Py_NewRef
static inline PyObject *
_PyAwaitable_NO_MANGLE(Py_NewRef)(PyObject *o)
{
    Py_INCREF(o);
    return o;
}

#endif

#ifndef Py_XNewRef
static inline PyObject *
_PyAwaitable_NO_MANGLE(Py_XNewRef)(PyObject *o)
{
    Py_XINCREF(o);
    return o;
}
#endif

#if PY_VERSION_HEX < 0x030c0000
static PyObject *
_PyAwaitable_NO_MANGLE(PyErr_GetRaisedException)(void)
{
    PyObject *type, *val, *tb;
    PyErr_Fetch(&type, &val, &tb);
    PyErr_NormalizeException(&type, &val, &tb);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    // technically some entry in the traceback might be lost; ignore that
    return val;
}

static void
_PyAwaitable_NO_MANGLE(PyErr_SetRaisedException)(PyObject *err)
{
    // NOTE: We need to incref the type object here, even though
    // this function steals a reference to err.
    PyErr_Restore(Py_NewRef((PyObject *) Py_TYPE(err)), err, NULL);
}
#endif

#endif

#ifndef PYAWAITABLE_CORO_H
#define PYAWAITABLE_CORO_H


#ifndef _PYAWAITABLE_VENDOR
_PyAwaitable_INTERNAL_DATA(PyMethodDef) pyawaitable_methods[];
#endif
_PyAwaitable_INTERNAL_DATA(PyAsyncMethods) pyawaitable_async_methods;

#endif

#ifndef PYAWAITABLE_AWAITABLE_H
#define PYAWAITABLE_AWAITABLE_H



typedef int (*PyAwaitable_Callback)(PyObject *, PyObject *);
typedef int (*PyAwaitable_Error)(PyObject *, PyObject *);
typedef int (*PyAwaitable_Defer)(PyObject *);

typedef struct ___PyAwaitable_Mangled_pyawaitable_callback {
    PyObject *coro;
    PyAwaitable_Callback callback;
    PyAwaitable_Error err_callback;
    bool done;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_callback);

struct _PyAwaitableObject {
    PyObject_HEAD

    __PyAwaitable_Mangled_pyawaitable_array aw_callbacks;
    __PyAwaitable_Mangled_pyawaitable_array aw_object_values;
    __PyAwaitable_Mangled_pyawaitable_array aw_arbitrary_values;
    __PyAwaitable_Mangled_pyawaitable_array aw_integer_values;

    /* Index of current callback */
    Py_ssize_t aw_state;
    /* Is the awaitable done? */
    bool aw_done;
    /* Was the awaitable awaited? */
    bool aw_awaited;
    /* Strong reference to the result of the coroutine. */
    PyObject *aw_result;
    /* Strong reference to the genwrapper. */
    PyObject *aw_gen;
    /* Set to 1 if the object was cancelled, for introspection against callbacks */
    int aw_recently_cancelled;
};

typedef struct _PyAwaitableObject PyAwaitableObject;
_PyAwaitable_INTERNAL_DATA(PyTypeObject) PyAwaitable_Type;

_PyAwaitable_API(int)
PyAwaitable_SetResult(PyObject * awaitable, PyObject * result);

_PyAwaitable_API(int)
PyAwaitable_AddAwait(
    PyObject * aw,
    PyObject * coro,
    PyAwaitable_Callback cb,
    PyAwaitable_Error err
);

_PyAwaitable_API(int)
PyAwaitable_DeferAwait(PyObject * aw, PyAwaitable_Defer cb);

_PyAwaitable_API(void)
PyAwaitable_Cancel(PyObject * aw);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_awaitable_next(PyObject * self);

_PyAwaitable_API(PyObject *)
PyAwaitable_New(void);

#endif

#ifndef PYAWAITABLE_GENWRAPPER_H
#define PYAWAITABLE_GENWRAPPER_H


_PyAwaitable_INTERNAL_DATA(PyTypeObject) _PyAwaitableGenWrapperType;

typedef struct ___PyAwaitable_Mangled_GenWrapperObject {
    PyObject_HEAD
    PyAwaitableObject *gw_aw;
    PyObject *gw_current_await;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_GenWrapperObject);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal__PyAwaitableGenWrapper_Next(PyObject * self);

_PyAwaitable_INTERNAL(int)
_PyAwaitableGenWrapper_FireErrCallback(
    PyObject * self,
    PyAwaitable_Error err_callback
);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_new(PyAwaitableObject * aw);

#endif

#ifndef PYAWAITABLE_VALUES_H
#define PYAWAITABLE_VALUES_H


/* Object values */

_PyAwaitable_API(int)
PyAwaitable_SaveValues(
    PyObject * awaitable,
    Py_ssize_t nargs,
    ...
);

_PyAwaitable_API(int)
PyAwaitable_UnpackValues(PyObject * awaitable, ...);

_PyAwaitable_API(int)
PyAwaitable_SetValue(
    PyObject * awaitable,
    Py_ssize_t index,
    PyObject * new_value
);
_PyAwaitable_API(PyObject *)
PyAwaitable_GetValue(
    PyObject * awaitable,
    Py_ssize_t index
);

/* Arbitrary values */

_PyAwaitable_API(int)
PyAwaitable_SaveArbValues(
    PyObject * awaitable,
    Py_ssize_t nargs,
    ...
);

_PyAwaitable_API(int)
PyAwaitable_UnpackArbValues(PyObject * awaitable, ...);

_PyAwaitable_API(int)
PyAwaitable_SetArbValue(
    PyObject * awaitable,
    Py_ssize_t index,
    void *new_value
);

_PyAwaitable_API(void *)
PyAwaitable_GetArbValue(
    PyObject * awaitable,
    Py_ssize_t index
);

/* Integer values */

_PyAwaitable_API(int)
PyAwaitable_SaveIntValues(
    PyObject * awaitable,
    Py_ssize_t nargs,
    ...
);

_PyAwaitable_API(int)
PyAwaitable_UnpackIntValues(PyObject * awaitable, ...);

_PyAwaitable_API(int)
PyAwaitable_SetIntValue(
    PyObject * awaitable,
    Py_ssize_t index,
    long new_value
);

_PyAwaitable_API(long)
PyAwaitable_GetIntValue(
    PyObject * awaitable,
    Py_ssize_t index
);

#endif

#ifndef PYAWAITABLE_WITH_H
#define PYAWAITABLE_WITH_H


_PyAwaitable_API(int)
PyAwaitable_AsyncWith(
    PyObject * aw,
    PyObject * ctx,
    PyAwaitable_Callback cb,
    PyAwaitable_Error err
);

#endif

#ifndef PYAWAITABLE_INIT_H
#define PYAWAITABLE_INIT_H


_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal__PyAwaitable_GetState(void);

_PyAwaitable_API(PyTypeObject *)
PyAwaitable_GetType(void);

_PyAwaitable_INTERNAL(PyTypeObject *)
__PyAwaitable_Internal__PyAwaitable_GetGenWrapperType(void);

_PyAwaitable_API(int)
PyAwaitable_Init(void);

#endif


static inline void
__PyAwaitable_Static_call_deallocator_maybe(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    if (array->deallocator != NULL && array->items[index] != NULL) {
        array->deallocator(array->items[index]);
        array->items[index] = NULL;
    }
}

_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_init_with_size(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
)
{
    assert(array != NULL);
    assert(initial > 0);
    void **items = PyMem_Calloc(sizeof(void *), initial);
    if (PyAwaitable_UNLIKELY(items == NULL)) {
        return -1;
    }

    array->capacity = initial;
    array->items = items;
    array->length = 0;
    array->deallocator = deallocator;

    return 0;
}

static int
__PyAwaitable_Static_resize_if_needed(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    if (array->length == array->capacity) {
        // Need to resize
        array->capacity *= 2;
        void **new_items = PyMem_Realloc(
            array->items,
            sizeof(void *) * array->capacity
        );
        if (PyAwaitable_UNLIKELY(new_items == NULL)) {
            return -1;
        }

        array->items = new_items;
    }

    return 0;
}

_PyAwaitable_INTERNAL(int) PyAwaitable_PURE
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(__PyAwaitable_Mangled_pyawaitable_array *array, void *item)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    array->items[array->length++] = item;
    if (__PyAwaitable_Static_resize_if_needed(array) < 0) {
        array->items[--array->length] = NULL;
        return -1;
    }
    return 0;
}

_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_insert(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    Py_ssize_t index,
    void *item
)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    ++array->length;
    if (__PyAwaitable_Static_resize_if_needed(array) < 0) {
        // Grow the array beforehand, otherwise it's
        // going to be a mess putting it back together if
        // allocation fails.
        --array->length;
        return -1;
    }

    for (Py_ssize_t i = array->length - 1; i > index; --i) {
        array->items[i] = array->items[i - 1];
    }

    array->items[index] = item;
    return 0;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index, void *item)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    __PyAwaitable_Static_call_deallocator_maybe(array, index);
    array->items[index] = item;
}

static void
__PyAwaitable_Static_remove_no_dealloc(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    for (Py_ssize_t i = index; i < array->length - 1; ++i) {
        array->items[i] = array->items[i + 1];
    }
    --array->length;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_remove(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    __PyAwaitable_Static_call_deallocator_maybe(array, index);
    __PyAwaitable_Static_remove_no_dealloc(array, index);
}

_PyAwaitable_INTERNAL(void *)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    void *item = array->items[index];
    __PyAwaitable_Static_remove_no_dealloc(array, index);
    return item;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(__PyAwaitable_Mangled_pyawaitable_array * array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    for (Py_ssize_t i = 0; i < array->length; ++i) {
        __PyAwaitable_Static_call_deallocator_maybe(array, i);
        array->items[i] = NULL;
    }

    array->length = 0;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(__PyAwaitable_Mangled_pyawaitable_array * array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(array);
    PyMem_Free(array->items);

    // It would be nice if others could reuse the allocation for another
    // dynarray later, so clear all the fields.
    array->items = NULL;
    array->length = 0;
    array->capacity = 0;
    array->deallocator = NULL;
}


static PyObject *
__PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(PyObject *self, PyObject *value)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    if (aw->aw_gen == NULL) {
        PyObject *gen = __PyAwaitable_Internal_awaitable_next(self);
        if (PyAwaitable_UNLIKELY(gen == NULL)) {
            return NULL;
        }

        if (PyAwaitable_UNLIKELY(value != Py_None)) {
            PyErr_SetString(
                PyExc_RuntimeError,
                "can't send non-None value to a just-started awaitable"
            );
            return NULL;
        }

        Py_DECREF(gen);
        Py_RETURN_NONE;
    }

    return __PyAwaitable_Internal__PyAwaitableGenWrapper_Next(aw->aw_gen);
}

static PyObject *
__PyAwaitable_Static_awaitable_send(PyObject *self, PyObject *value)
{
    return __PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(self, value);
}

static PyObject *
__PyAwaitable_Static_awaitable_close(PyObject *self, PyObject *args)
{
    PyAwaitable_Cancel(self);
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    aw->aw_done = true;
    Py_RETURN_NONE;
}

static PyObject *
__PyAwaitable_Static_awaitable_throw(PyObject *self, PyObject *args)
{
    PyObject *type;
    PyObject *value = NULL;
    PyObject *traceback = NULL;

    if (!PyArg_ParseTuple(args, "O|OO", &type, &value, &traceback)) {
        return NULL;
    }

    if (PyType_Check(type)) {
        PyObject *err = PyObject_CallOneArg(type, value);
        if (PyAwaitable_UNLIKELY(err == NULL)) {
            return NULL;
        }

        if (traceback != NULL) {
            if (PyException_SetTraceback(err, traceback) < 0) {
                Py_DECREF(err);
                return NULL;
            }
        }

        PyErr_Restore(err, NULL, NULL);
    }
    else {
        PyErr_Restore(
            Py_NewRef(type),
            Py_XNewRef(value),
            Py_XNewRef(traceback)
        );
    }

    PyAwaitableObject *aw = (PyAwaitableObject *)self;
    if ((aw->aw_gen != NULL) && (aw->aw_state != 0)) {
        __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *)aw->aw_gen;
        __PyAwaitable_Mangled_pyawaitable_callback *cb =
            __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(&aw->aw_callbacks, aw->aw_state - 1);
        if (cb == NULL) {
            return NULL;
        }

        if (_PyAwaitableGenWrapper_FireErrCallback(
            self,
            cb->err_callback
            ) < 0) {
            return NULL;
        }
    }
    else {
        return NULL;
    }

    assert(PyErr_Occurred());
    return NULL;
}

#if PY_MINOR_VERSION > 9
static PySendResult
__PyAwaitable_Static_awaitable_am_send(PyObject *self, PyObject *arg, PyObject **presult)
{
    PyObject *send_res = __PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(self, arg);
    if (send_res == NULL) {
        if (PyErr_ExceptionMatches(PyExc_StopIteration)) {
            PyObject *occurred = PyErr_GetRaisedException();
            PyObject *item = PyObject_GetAttrString(occurred, "value");
            Py_DECREF(occurred);

            if (PyAwaitable_UNLIKELY(item == NULL)) {
                return PYGEN_ERROR;
            }

            *presult = item;
            return PYGEN_RETURN;
        }
        *presult = NULL;
        return PYGEN_ERROR;
    }
    *presult = send_res;

    return PYGEN_NEXT;
}

#endif

_PyAwaitable_INTERNAL_DATA_DEF(PyMethodDef) pyawaitable_methods[] = {
    {"send", __PyAwaitable_Static_awaitable_send, METH_O, NULL},
    {"close", __PyAwaitable_Static_awaitable_close, METH_NOARGS, NULL},
    {"throw", __PyAwaitable_Static_awaitable_throw, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};

_PyAwaitable_INTERNAL_DATA_DEF(PyAsyncMethods) pyawaitable_async_methods = {
#if PY_MINOR_VERSION > 9
    .am_await = __PyAwaitable_Internal_awaitable_next,
    .am_send = __PyAwaitable_Static_awaitable_am_send
#else
    .am_await = __PyAwaitable_Internal_awaitable_next
#endif
};



static void
__PyAwaitable_Static_callback_dealloc(void *ptr)
{
    assert(ptr != NULL);
    __PyAwaitable_Mangled_pyawaitable_callback *cb = (__PyAwaitable_Mangled_pyawaitable_callback *) ptr;
    Py_CLEAR(cb->coro);
    PyMem_Free(cb);
}

static PyObject *
__PyAwaitable_Static_awaitable_new_func(PyTypeObject *tp, PyObject *args, PyObject *kwds)
{
    assert(tp != NULL);
    assert(tp->tp_alloc != NULL);

    PyObject *self = tp->tp_alloc(tp, 0);
    if (PyAwaitable_UNLIKELY(self == NULL)) {
        return NULL;
    }

    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    aw->aw_gen = NULL;
    aw->aw_done = false;
    aw->aw_state = 0;
    aw->aw_result = NULL;
    aw->aw_recently_cancelled = 0;

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_callbacks, __PyAwaitable_Static_callback_dealloc) < 0) {
        goto error;
    }

    if (
        __PyAwaitable_Mangled_pyawaitable_array_init(
            &aw->aw_object_values,
            (__PyAwaitable_Mangled_pyawaitable_array_deallocator) Py_DecRef
        ) < 0
    ) {
        goto error;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_arbitrary_values, NULL) < 0) {
        goto error;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_integer_values, NULL) < 0) {
        goto error;
    }

    return self;
error:
    PyErr_NoMemory();
    Py_DECREF(self);
    return NULL;
}

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_awaitable_next(PyObject * self)
{
    PyAwaitableObject *aw = (PyAwaitableObject *)self;
    if (aw->aw_done) {
        PyErr_SetString(
            PyExc_RuntimeError,
            "PyAwaitable: Cannot reuse awaitable"
        );
        return NULL;
    }
    aw->aw_awaited = true;
    PyObject *gen = __PyAwaitable_Internal_genwrapper_new(aw);
    aw->aw_gen = Py_XNewRef(gen);
    return gen;
}

static void
__PyAwaitable_Static_awaitable_dealloc(PyObject *self)
{
    PyAwaitableObject *aw = (PyAwaitableObject *)self;
#define CLEAR_IF_NON_NULL(array)             \
        if (array.items != NULL) {           \
            __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(&array); \
        }
    CLEAR_IF_NON_NULL(aw->aw_callbacks);
    CLEAR_IF_NON_NULL(aw->aw_object_values);
    CLEAR_IF_NON_NULL(aw->aw_arbitrary_values);
    CLEAR_IF_NON_NULL(aw->aw_integer_values);
#undef CLEAR_IF_NON_NULL

    Py_XDECREF(aw->aw_gen);
    Py_XDECREF(aw->aw_result);

    if (!aw->aw_awaited) {
        if (
            PyErr_WarnEx(
                PyExc_ResourceWarning,
                "PyAwaitable object was never awaited",
                1
            ) < 0
        ) {
            PyErr_WriteUnraisable(self);
        }
    }

    Py_TYPE(self)->tp_free(self);
}

_PyAwaitable_API(void)
PyAwaitable_Cancel(PyObject * self)
{
    assert(self != NULL);
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    __PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(&aw->aw_callbacks);
    aw->aw_state = 0;
    if (aw->aw_gen != NULL) {
        __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *)aw->aw_gen;
        Py_CLEAR(gw->gw_current_await);
    }

    aw->aw_recently_cancelled = 1;
    aw->aw_awaited = 1;
}

_PyAwaitable_API(int)
PyAwaitable_AddAwait(
    PyObject * self,
    PyObject * coro,
    PyAwaitable_Callback cb,
    PyAwaitable_Error err
)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    if (coro == NULL) {
        PyErr_SetString(
            PyExc_ValueError,
            "PyAwaitable: NULL passed to PyAwaitable_AddAwait()! "
            "Did you forget an error check?"
        );
        return -1;
    }

    if (coro == self) {
        PyErr_Format(
            PyExc_ValueError,
            "PyAwaitable: Self (%R) was passed to PyAwaitable_AddAwait()! "
            "This would result in a recursive nightmare.",
            self
        );
        return -1;
    }

    if (!PyObject_HasAttrString(coro, "__await__")) {
        PyErr_Format(
            PyExc_TypeError,
            "PyAwaitable: %R is not an awaitable object",
            coro
        );
        return -1;
    }

    __PyAwaitable_Mangled_pyawaitable_callback *aw_c = PyMem_Malloc(sizeof(__PyAwaitable_Mangled_pyawaitable_callback));
    if (aw_c == NULL) {
        PyErr_NoMemory();
        return -1;
    }

    aw_c->coro = Py_NewRef(coro);
    aw_c->callback = cb;
    aw_c->err_callback = err;
    aw_c->done = false;

    if (__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(&aw->aw_callbacks, aw_c) < 0) {
        PyMem_Free(aw_c);
        PyErr_NoMemory();
        return -1;
    }

    return 0;
}

_PyAwaitable_API(int)
PyAwaitable_DeferAwait(PyObject * awaitable, PyAwaitable_Defer cb)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;
    __PyAwaitable_Mangled_pyawaitable_callback *aw_c = PyMem_Malloc(sizeof(__PyAwaitable_Mangled_pyawaitable_callback));
    if (aw_c == NULL) {
        PyErr_NoMemory();
        return -1;
    }

    aw_c->coro = NULL;
    aw_c->callback = (PyAwaitable_Callback)cb;
    aw_c->err_callback = NULL;
    aw_c->done = false;

    if (__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(&aw->aw_callbacks, aw_c) < 0) {
        PyMem_Free(aw_c);
        PyErr_NoMemory();
        return -1;
    }

    return 0;
}

_PyAwaitable_API(int)
PyAwaitable_SetResult(PyObject * awaitable, PyObject * result)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;
    aw->aw_result = Py_NewRef(result);
    return 0;
}

_PyAwaitable_API(PyObject *)
PyAwaitable_New(void)
{
    // XXX Use a freelist?
    PyTypeObject *type = PyAwaitable_GetType();
    if (PyAwaitable_UNLIKELY(type == NULL)) {
        return NULL;
    }
    PyObject *result = __PyAwaitable_Static_awaitable_new_func(type, NULL, NULL);
    return result;
}

_PyAwaitable_INTERNAL_DATA_DEF(PyTypeObject) PyAwaitable_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_PyAwaitableType",
    .tp_basicsize = sizeof(PyAwaitableObject),
    .tp_dealloc = __PyAwaitable_Static_awaitable_dealloc,
    .tp_as_async = &pyawaitable_async_methods,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_doc = PyDoc_STR("Awaitable transport utility for the C API."),
    .tp_iternext = __PyAwaitable_Internal_awaitable_next,
    .tp_new = __PyAwaitable_Static_awaitable_new_func,
    .tp_methods = pyawaitable_methods
};

#define DONE(cb)                 \
        do { cb->done = true;    \
             Py_CLEAR(cb->coro); \
             Py_CLEAR(g->gw_current_await); } while (0)
#define AW_DONE()               \
        do {                    \
            aw->aw_done = true; \
            Py_CLEAR(g->gw_aw); \
        } while (0)
#define DONE_IF_OK(cb)                        \
        if (PyAwaitable_LIKELY(cb != NULL)) { \
            DONE(cb);                         \
        }
#define DONE_IF_OK_AND_CHECK(cb)                               \
        if (PyAwaitable_UNLIKELY(aw->aw_recently_cancelled)) { \
            cb = NULL;                                         \
        }                                                      \
        else {                                                 \
            DONE(cb);                                          \
        }
/* If we recently cancelled, then cb is no longer valid */
#define CLEAR_CALLBACK_IF_CANCELLED()                          \
        if (PyAwaitable_UNLIKELY(aw->aw_recently_cancelled)) { \
            cb = NULL;                                         \
        }                                                      \

#define FIRE_ERROR_CALLBACK_AND_NEXT()      \
        if (                                \
    _PyAwaitableGenWrapper_FireErrCallback( \
    (PyObject *) aw,                        \
    cb->err_callback                        \
    ) < 0                                   \
        ) {                                 \
            DONE_IF_OK_AND_CHECK(cb);       \
            AW_DONE();                      \
            return NULL;                    \
        }                                   \
        DONE_IF_OK_AND_CHECK(cb);           \
        return __PyAwaitable_Internal__PyAwaitableGenWrapper_Next(self);
#define RETURN_ADVANCE_GENERATOR() \
        DONE_IF_OK(cb);            \
        PyAwaitable_MUSTTAIL return __PyAwaitable_Internal__PyAwaitableGenWrapper_Next(self);

static PyObject *
__PyAwaitable_Static_gen_new(PyTypeObject *tp, PyObject *args, PyObject *kwds)
{
    assert(tp != NULL);
    assert(tp->tp_alloc != NULL);

    PyObject *self = tp->tp_alloc(tp, 0);
    if (PyAwaitable_UNLIKELY(self == NULL)) {
        return NULL;
    }

    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    g->gw_aw = NULL;
    g->gw_current_await = NULL;

    return (PyObject *) g;
}

static int
__PyAwaitable_Static_genwrapper_traverse(PyObject *self, visitproc visit, void *arg)
{
    __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    Py_VISIT(gw->gw_current_await);
    Py_VISIT(gw->gw_aw);
    return 0;
}

static int
__PyAwaitable_Static_genwrapper_clear(PyObject *self)
{
    __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    Py_CLEAR(gw->gw_current_await);
    Py_CLEAR(gw->gw_aw);
    return 0;
}

static void
__PyAwaitable_Static_gen_dealloc(PyObject *self)
{
    PyObject_GC_UnTrack(self);
    (void)__PyAwaitable_Static_genwrapper_clear(self);
    Py_TYPE(self)->tp_free(self);
}

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_new(PyAwaitableObject * aw)
{
    assert(aw != NULL);
    PyTypeObject *type = __PyAwaitable_Internal__PyAwaitable_GetGenWrapperType();
    if (PyAwaitable_UNLIKELY(type == NULL)) {
        return NULL;
    }
    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *) __PyAwaitable_Static_gen_new(
        type,
        NULL,
        NULL
    );

    if (PyAwaitable_UNLIKELY(g == NULL)) {
        return NULL;
    }

    g->gw_aw = (PyAwaitableObject *) Py_NewRef((PyObject *) aw);
    return (PyObject *) g;
}

_PyAwaitable_INTERNAL(int)
_PyAwaitableGenWrapper_FireErrCallback(
    PyObject * self,
    PyAwaitable_Error err_callback
)
{
    assert(PyErr_Occurred() != NULL);
    if (err_callback == NULL) {
        return -1;
    }

    PyObject *err = PyErr_GetRaisedException();

    Py_INCREF(self);
    int e_res = err_callback(self, err);
    Py_DECREF(self);

    if (e_res < 0) {
        // If the res is -1, the error is restored.
        // Otherwise, it is not.
        if (e_res == -1) {
            PyErr_SetRaisedException(err);
        }
        else {
            Py_DECREF(err);
        }
        return -1;
    }

    Py_DECREF(err);
    return 0;
}

static inline __PyAwaitable_Mangled_pyawaitable_callback *
__PyAwaitable_Static_genwrapper_advance(__PyAwaitable_Mangled_GenWrapperObject *gw)
{
    return __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(
        &gw->gw_aw->aw_callbacks,
        gw->gw_aw->aw_state++
    );
}

static PyObject *
__PyAwaitable_Static_get_generator_return_value(void)
{
    PyObject *value;
    if (PyErr_Occurred()) {
        value = PyErr_GetRaisedException();
        assert(value != NULL);
        assert(PyObject_IsInstance(value, PyExc_StopIteration));
        PyObject *tmp = PyObject_GetAttrString(value, "value");
        if (PyAwaitable_UNLIKELY(tmp == NULL)) {
            Py_DECREF(value);
            return NULL;
        }
        Py_DECREF(value);
        value = tmp;
    }
    else {
        value = Py_NewRef(Py_None);
    }

    return value;
}

static int
__PyAwaitable_Static_maybe_set_result(PyAwaitableObject *aw)
{
    if (__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(&aw->aw_callbacks) == aw->aw_state) {
        PyErr_SetObject(
            PyExc_StopIteration,
            aw->aw_result ? aw->aw_result : Py_None
        );
        return 1;
    }

    return 0;
}

static inline PyAwaitable_COLD PyObject *
__PyAwaitable_Static_bad_callback(void)
{
    PyErr_SetString(
        PyExc_SystemError,
        "PyAwaitable: User callback returned -1 without exception set"
    );
    return NULL;
}

static inline PyObject *
__PyAwaitable_Static_get_awaitable_iterator(PyObject *op)
{
    if (
        PyAwaitable_UNLIKELY(
            Py_TYPE(op)->tp_as_async == NULL ||
            Py_TYPE(op)->tp_as_async->am_await == NULL
        )
    ) {
        // Fall back to the dunder
        PyObject *__await__ = PyObject_GetAttrString(op, "__await__");
        if (__await__ == NULL) {
            return NULL;
        }

        PyObject *res = PyObject_CallNoArgs(__await__);
        Py_DECREF(__await__);
        return res;
    }

    return Py_TYPE(op)->tp_as_async->am_await(op);
}

_PyAwaitable_INTERNAL(PyObject *) PyAwaitable_HOT
__PyAwaitable_Internal__PyAwaitableGenWrapper_Next(PyObject *self)
{
    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *)self;
    PyAwaitableObject *aw = g->gw_aw;

    if (PyAwaitable_UNLIKELY(aw == NULL)) {
        PyErr_SetString(
            PyExc_RuntimeError,
            "PyAwaitable: Generator cannot be awaited after returning"
        );
        return NULL;
    }

    __PyAwaitable_Mangled_pyawaitable_callback *cb;

    if (g->gw_current_await == NULL) {
        if (__PyAwaitable_Static_maybe_set_result(aw)) {
            // Coroutine is done, woohoo!
            AW_DONE();
            return NULL;
        }

        cb = __PyAwaitable_Static_genwrapper_advance(g);
        assert(cb != NULL);
        assert(cb->done == false);

        if (cb->callback != NULL && cb->coro == NULL) {
            int def_res = ((PyAwaitable_Defer)cb->callback)((PyObject *)aw);
            CLEAR_CALLBACK_IF_CANCELLED();
            if (def_res < 0) {
                DONE_IF_OK(cb);
                AW_DONE();
                return NULL;
            }

            // Callback is done.
            RETURN_ADVANCE_GENERATOR();
        }

        assert(cb->coro != NULL);
        g->gw_current_await = __PyAwaitable_Static_get_awaitable_iterator(cb->coro);
        if (g->gw_current_await == NULL) {
            FIRE_ERROR_CALLBACK_AND_NEXT();
        }
    }
    else {
        cb = __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(&aw->aw_callbacks, aw->aw_state - 1);
    }

    PyObject *result = Py_TYPE(
        g->gw_current_await
    )->tp_iternext(g->gw_current_await);

    if (result != NULL) {
        // Yield!
        return result;
    }

    // Rare, but it's possible that the generator cancelled us
    CLEAR_CALLBACK_IF_CANCELLED();

    PyObject *occurred = PyErr_Occurred();
    if (!occurred) {
        // Coro is done, no result.
        if (cb == NULL || !cb->callback) {
            // No callback, skip trying to handle anything
            RETURN_ADVANCE_GENERATOR();
        }
    }

    if (occurred && !PyErr_ExceptionMatches(PyExc_StopIteration)) {
        // An error occurred!
        FIRE_ERROR_CALLBACK_AND_NEXT();
    }

    /* Coroutine is done, but with a result. */
    if (cb == NULL || cb->callback == NULL) {
        // We can disregard the result if there's no callback.
        PyErr_Clear();
        RETURN_ADVANCE_GENERATOR();
    }

    assert(cb != NULL);
    // Deduce the return value of the coroutine
    PyObject *value = __PyAwaitable_Static_get_generator_return_value();
    if (value == NULL) {
        DONE(cb);
        AW_DONE();
        return NULL;
    }

    // Preserve the error callback in case we get cancelled
    PyAwaitable_Error err_callback = cb->err_callback;
    Py_INCREF(aw);
    int res = cb->callback((PyObject *) aw, value);
    Py_DECREF(aw);
    Py_DECREF(value);

    CLEAR_CALLBACK_IF_CANCELLED();

    if (res < -1) {
        // -2 or lower denotes that the error should be deferred,
        // regardless of whether a handler is present.
        DONE_IF_OK(cb);
        AW_DONE();
        return NULL;
    }

    if (res < 0) {
        FIRE_ERROR_CALLBACK_AND_NEXT();
    }

    RETURN_ADVANCE_GENERATOR();
}

_PyAwaitable_INTERNAL_DATA_DEF(PyTypeObject) _PyAwaitableGenWrapperType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_PyAwaitableGenWrapperType",
    .tp_basicsize = sizeof(__PyAwaitable_Mangled_GenWrapperObject),
    .tp_dealloc = __PyAwaitable_Static_gen_dealloc,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    .tp_iter = PyObject_SelfIter,
    .tp_iternext = __PyAwaitable_Internal__PyAwaitableGenWrapper_Next,
    .tp_clear = __PyAwaitable_Static_genwrapper_clear,
    .tp_traverse = __PyAwaitable_Static_genwrapper_traverse,
    .tp_new = __PyAwaitable_Static_gen_new,
};



#define NOTHING

#define SAVE(field, type, extra)                                    \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;    \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                      \
        va_list vargs;                                              \
        va_start(vargs, nargs);                                     \
        for (Py_ssize_t i = 0; i < nargs; ++i) {                    \
            type ptr = va_arg(vargs, type);                         \
            assert((void *)ptr != NULL);                            \
            if (__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(array, (void *)ptr) < 0) { \
                PyErr_NoMemory();                                   \
                return -1;                                          \
            }                                                       \
            extra;                                                  \
        }                                                           \
        va_end(vargs);                                              \
        return 0

#define UNPACK(field, type)                                                \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;           \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                             \
        if (__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array) == 0) {                        \
            PyErr_SetString(                                               \
    PyExc_RuntimeError,                                                    \
    "PyAwaitable: Object has no stored values"                             \
            );                                                             \
            return -1;                                                     \
        }                                                                  \
        va_list vargs;                                                     \
        va_start(vargs, awaitable);                                        \
        for (Py_ssize_t i = 0; i < __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array); ++i) { \
            type *ptr = va_arg(vargs, type *);                             \
            if (ptr == NULL) {                                             \
                continue;                                                  \
            }                                                              \
            *ptr = (type)__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(array, i);             \
        }                                                                  \
        va_end(vargs);                                                     \
        return 0

#define SET(field, type)                                          \
        assert(awaitable != NULL);                                \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;  \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                    \
        if (__PyAwaitable_Static_check_index(index, array) < 0) {                      \
            return -1;                                            \
        }                                                         \
        __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(array, index, (void *)(new_value)); \
        return 0

#define GET(field, type)                                         \
        assert(awaitable != NULL);                               \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable; \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                   \
        if (__PyAwaitable_Static_check_index(index, array) < 0) {                     \
            return (type)NULL;                                   \
        }                                                        \
        return (type)__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(array, index)

static int
__PyAwaitable_Static_check_index(Py_ssize_t index, __PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    if (PyAwaitable_UNLIKELY(index < 0)) {
        PyErr_SetString(
            PyExc_IndexError,
            "PyAwaitable: Cannot set negative index"
        );
        return -1;
    }

    if (PyAwaitable_UNLIKELY(index >= __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array))) {
        PyErr_SetString(
            PyExc_IndexError,
            "PyAwaitable: Cannot set index that is out of bounds"
        );
        return -1;
    }

    return 0;
}

_PyAwaitable_API(int)
PyAwaitable_UnpackValues(PyObject * awaitable, ...)
{
    UNPACK(aw_object_values, PyObject *);
}

_PyAwaitable_API(int)
PyAwaitable_SaveValues(PyObject * awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_object_values, PyObject *, Py_INCREF(ptr));
}

_PyAwaitable_API(int)
PyAwaitable_SetValue(
    PyObject * awaitable,
    Py_ssize_t index,
    PyObject * new_value
)
{
    SET(aw_object_values, Py_NewRef);
}

_PyAwaitable_API(PyObject *)
PyAwaitable_GetValue(
    PyObject * awaitable,
    Py_ssize_t index
)
{
    GET(aw_object_values, PyObject *);
}

/* Arbitrary Values */

_PyAwaitable_API(int)
PyAwaitable_UnpackArbValues(PyObject * awaitable, ...)
{
    UNPACK(aw_arbitrary_values, void *);
}

_PyAwaitable_API(int)
PyAwaitable_SaveArbValues(PyObject * awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_arbitrary_values, void *, NOTHING);
}

_PyAwaitable_API(int)
PyAwaitable_SetArbValue(
    PyObject * awaitable,
    Py_ssize_t index,
    void *new_value
)
{
    SET(aw_arbitrary_values, void *);
}

_PyAwaitable_API(void *)
PyAwaitable_GetArbValue(
    PyObject * awaitable,
    Py_ssize_t index
)
{
    GET(aw_arbitrary_values, void *);
}

/* Integer Values */

_PyAwaitable_API(int)
PyAwaitable_UnpackIntValues(PyObject * awaitable, ...)
{
    UNPACK(aw_integer_values, long);
}

_PyAwaitable_API(int)
PyAwaitable_SaveIntValues(PyObject * awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_integer_values, long, NOTHING);
}

_PyAwaitable_API(int)
PyAwaitable_SetIntValue(
    PyObject * awaitable,
    Py_ssize_t index,
    long new_value
)
{
    SET(aw_integer_values, long);
}

_PyAwaitable_API(long)
PyAwaitable_GetIntValue(
    PyObject * awaitable,
    Py_ssize_t index
)
{
    GET(aw_integer_values, long);
}


static int
__PyAwaitable_Static_async_with_inner(PyObject *aw, PyObject *res)
{
    PyAwaitable_Callback cb;
    PyAwaitable_Error err;
    PyObject *exit;
    if (PyAwaitable_UnpackArbValues(aw, &cb, &err) < 0) {
        return -1;
    }

    if (PyAwaitable_UnpackValues(aw, &exit) < 0) {
        return -1;
    }

    Py_INCREF(aw);
    Py_INCREF(res);
    int callback_result = cb != NULL ? cb(aw, res) : 0;
    Py_DECREF(res);
    Py_DECREF(aw);

    if (callback_result < 0) {
        PyObject *tp, *val, *tb;
        PyErr_Fetch(&tp, &val, &tb);
        PyErr_NormalizeException(&tp, &val, &tb);

        if (tp == NULL) {
            PyErr_SetString(
                PyExc_SystemError,
                "pyawaitable: async with callback returned -1 without exception set"
            );
            return -1;
        }

        // Traceback can still be NULL
        if (tb == NULL)
            tb = Py_NewRef(Py_None);

        PyObject *coro = PyObject_Vectorcall(
            exit,
            (PyObject *[]) { tp, val, tb },
            3,
            NULL
        );
        Py_DECREF(tp);
        Py_DECREF(val);
        Py_DECREF(tb);
        if (coro == NULL) {
            return -1;
        }

        if (PyAwaitable_AddAwait(aw, coro, NULL, NULL) < 0) {
            Py_DECREF(coro);
            return -1;
        }

        Py_DECREF(coro);
        return 0;
    }
    else {
        // OK
        PyObject *coro = PyObject_Vectorcall(
            exit,
            (PyObject *[]) { Py_None, Py_None, Py_None },
            3,
            NULL
        );
        if (coro == NULL) {
            return -1;
        }

        if (PyAwaitable_AddAwait(aw, coro, NULL, NULL) < 0) {
            Py_DECREF(coro);
            return -1;
        }
        Py_DECREF(coro);
        return 0;
    }
}

_PyAwaitable_API(int)
PyAwaitable_AsyncWith(
    PyObject * aw,
    PyObject * ctx,
    PyAwaitable_Callback cb,
    PyAwaitable_Error err
)
{
    PyObject *with = PyObject_GetAttrString(ctx, "__aenter__");
    if (with == NULL) {
        PyErr_Format(
            PyExc_TypeError,
            "pyawaitable: %R is not an async context manager (missing __aenter__)",
            ctx
        );
        return -1;
    }
    PyObject *exit = PyObject_GetAttrString(ctx, "__aexit__");
    if (exit == NULL) {
        Py_DECREF(with);
        PyErr_Format(
            PyExc_TypeError,
            "pyawaitable: %R is not an async context manager (missing __aexit__)",
            ctx
        );
        return -1;
    }

    PyObject *inner_aw = PyAwaitable_New();

    if (inner_aw == NULL) {
        Py_DECREF(with);
        Py_DECREF(exit);
        return -1;
    }

    if (PyAwaitable_SaveArbValues(inner_aw, 2, cb, err) < 0) {
        Py_DECREF(inner_aw);
        Py_DECREF(with);
        Py_DECREF(exit);
        return -1;
    }

    if (PyAwaitable_SaveValues(inner_aw, 1, exit) < 0) {
        Py_DECREF(inner_aw);
        Py_DECREF(exit);
        Py_DECREF(with);
        return -1;
    }

    Py_DECREF(exit);

    PyObject *coro = PyObject_CallNoArgs(with);
    Py_DECREF(with);

    if (coro == NULL) {
        Py_DECREF(inner_aw);
        return -1;
    }

    // Note: Errors in __aenter__ are not sent to __aexit__
    if (
        PyAwaitable_AddAwait(
            inner_aw,
            coro,
            __PyAwaitable_Static_async_with_inner,
            NULL
        ) < 0
    ) {
        Py_DECREF(inner_aw);
        Py_DECREF(coro);
        return -1;
    }

    Py_DECREF(coro);

    if (PyAwaitable_AddAwait(aw, inner_aw, NULL, err) < 0) {
        Py_DECREF(inner_aw);
        return -1;
    }

    Py_DECREF(inner_aw);
    return 0;
}


static int
__PyAwaitable_Static_dict_add_type(PyObject *state, PyTypeObject *obj)
{
    assert(obj != NULL);
    assert(state != NULL);
    assert(PyDict_Check(state));
    assert(obj->tp_name != NULL);

    Py_INCREF(obj);
    if (PyType_Ready(obj) < 0) {
        Py_DECREF(obj);
        return -1;
    }

    if (PyDict_SetItemString(state, obj->tp_name, (PyObject *)obj) < 0) {
        Py_DECREF(obj);
        return -1;
    }
    Py_DECREF(obj);
    return 0;
}

static int
__PyAwaitable_Static_init_state(PyObject *state)
{
    assert(state != NULL);
    assert(PyDict_Check(state));
    if (__PyAwaitable_Static_dict_add_type(state, &PyAwaitable_Type) < 0) {
        return -1;
    }

    if (__PyAwaitable_Static_dict_add_type(state, &_PyAwaitableGenWrapperType) < 0) {
        return -1;
    }

    PyObject *version = PyLong_FromLong(PyAwaitable_MAGIC_NUMBER);
    if (version == NULL) {
        return -1;
    }

    if (PyDict_SetItemString(state, "magic_version", version) < 0) {
        Py_DECREF(version);
        return -1;
    }

    Py_DECREF(version);
    return 0;
}

static PyObject *
__PyAwaitable_Static_create_state(void)
{
    PyObject *state = PyDict_New();
    if (state == NULL) {
        return NULL;
    }

    if (__PyAwaitable_Static_init_state(state) < 0) {
        Py_DECREF(state);
        return NULL;
    }

    return state;
}

static PyObject *
__PyAwaitable_Static_interp_get_dict(void)
{
    PyInterpreterState *interp = PyInterpreterState_Get();
    assert(interp != NULL);
    PyObject *interp_state = PyInterpreterState_GetDict(interp);
    if (interp_state == NULL) {
        // Would be a memory error or something more exotic, but
        // there's nothing we can do.
        PyErr_SetString(
            PyExc_RuntimeError,
            "PyAwaitable: Interpreter failed to provide a state dictionary"
        );
        return NULL;
    }

    return interp_state;
}

static inline PyObject *
__PyAwaitable_Static_not_initialized(void)
{
    PyErr_SetString(
        PyExc_RuntimeError,
        "PyAwaitable hasn't been initialized yet! "
        "Did you forget to call PyAwaitable_Init()?"
    );
    return NULL;
}

static inline int
__PyAwaitable_Static_state_corrupted(const char *err, PyObject *found)
{
    assert(err != NULL);
    assert(found != NULL);
    PyErr_Format(
        PyExc_SystemError,
        "PyAwaitable corruption! %s: %R",
        err,
        found
    );
    Py_DECREF(found);
    return -1;
}

static PyObject *
__PyAwaitable_Static_get_state_value(PyObject *state, const char *name)
{
    assert(name != NULL);
    PyObject *str = PyUnicode_FromString(name);
    if (str == NULL) {
        return NULL;
    }

    PyObject *version = PyDict_GetItemWithError(state, str);
    Py_DECREF(str);
    return version;
}

static long
__PyAwaitable_Static_get_state_version(PyObject *state)
{
    assert(state != NULL);
    assert(PyDict_Check(state));

    PyObject *version = __PyAwaitable_Static_get_state_value(state, "magic_version");
    if (version == NULL) {
        return -1;
    }

    if (!PyLong_CheckExact(version)) {
        return __PyAwaitable_Static_state_corrupted("Non-int version number", version);
    }

    long version_num = PyLong_AsLong(version);
    if (version_num == -1 && PyErr_Occurred()) {
        Py_DECREF(version);
        return -1;
    }

    if (version_num < 0) {
        return __PyAwaitable_Static_state_corrupted("Found <0 version somehow", version);
    }

    return version_num;
}

static PyObject *
__PyAwaitable_Static_find_module_for_version(PyObject *interp_dict, long version)
{
    PyObject *list = PyDict_GetItemString(interp_dict, "_pyawaitable_states");
    if (list == NULL) {
        return __PyAwaitable_Static_not_initialized();
    }

    if (!PyList_CheckExact(list)) {
        __PyAwaitable_Static_state_corrupted("_pyawaitable_states is not a list", list);
        return NULL;
    }

    for (Py_ssize_t i = 0; i < PyList_GET_SIZE(list); ++i) {
        PyObject *mod = PyList_GET_ITEM(list, i);
        long got_version = __PyAwaitable_Static_get_state_version(mod);

        if (got_version == -1) {
            return NULL;
        }

        if (got_version == version) {
            return mod;
        }
    }

    return __PyAwaitable_Static_not_initialized();
}

static PyObject *
__PyAwaitable_Static_find_top_level_state(PyObject **interp_dict)
{
    PyObject *dict = __PyAwaitable_Static_interp_get_dict();
    if (dict == NULL) {
        return NULL;
    }

    PyObject *mod = PyDict_GetItemString(dict, "_pyawaitable_state");
    if (mod == NULL) {
        return __PyAwaitable_Static_not_initialized();
    }

    if (interp_dict != NULL) {
        *interp_dict = dict;
    }
    return mod;
}

static PyAwaitable_thread_local PyObject *pyawaitable_fast_state = NULL;

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal__PyAwaitable_GetState(void)
{
    if (pyawaitable_fast_state != NULL) {
        return pyawaitable_fast_state;
    }

    PyObject *interp_dict;
    PyObject *state = __PyAwaitable_Static_find_top_level_state(&interp_dict); // Borrowed reference
    if (state == NULL) {
        return NULL;
    }

    long version = __PyAwaitable_Static_get_state_version(state);
    if (version == -1) {
        return NULL;
    }

    if (version != PyAwaitable_MAGIC_NUMBER) {
        // Not our module!
        state = __PyAwaitable_Static_find_module_for_version(interp_dict, PyAwaitable_MAGIC_NUMBER);
        if (state == NULL) {
            return NULL;
        }
    }

    // We want this to be a borrowed reference
    pyawaitable_fast_state = state;
    return state;
}

static PyAwaitable_thread_local PyTypeObject *pyawaitable_fast_aw = NULL;
static PyAwaitable_thread_local PyTypeObject *pyawaitable_fast_gw = NULL;

_PyAwaitable_API(PyTypeObject *)
PyAwaitable_GetType(void)
{
    if (pyawaitable_fast_aw != NULL) {
        return pyawaitable_fast_aw;
    }
    PyObject *state = __PyAwaitable_Internal__PyAwaitable_GetState();
    if (state == NULL) {
        return NULL;
    }

    PyTypeObject *pyawaitable_type = (PyTypeObject *)__PyAwaitable_Static_get_state_value(
        state,
        "_PyAwaitableType"
    );
    if (pyawaitable_type == NULL) {
        return NULL;
    }

    // Should be an immortal reference
    pyawaitable_fast_aw = pyawaitable_type;
    return pyawaitable_type;
}


_PyAwaitable_INTERNAL(PyTypeObject *)
__PyAwaitable_Internal__PyAwaitable_GetGenWrapperType(void)
{
    if (pyawaitable_fast_gw != NULL) {
        return pyawaitable_fast_gw;
    }
    PyObject *state = __PyAwaitable_Internal__PyAwaitable_GetState();
    if (state == NULL) {
        return NULL;
    }

    PyTypeObject *gw_type = (PyTypeObject *)__PyAwaitable_Static_get_state_value(
        state,
        "_PyAwaitableGenWrapperType"
    );
    if (gw_type == NULL) {
        return NULL;
    }

    pyawaitable_fast_gw = gw_type;
    return (PyTypeObject *)gw_type;
}

static int
__PyAwaitable_Static_add_state_to_list(PyObject *interp_dict, PyObject *state)
{
    assert(interp_dict != NULL);
    assert(state != NULL);
    assert(PyDict_Check(interp_dict));
    assert(PyDict_Check(state));

    PyObject *pyawaitable_list = Py_XNewRef(
        PyDict_GetItemString(
            interp_dict,
            "_pyawaitable_states"
        )
    );
    if (pyawaitable_list == NULL) {
        // No list has been set
        pyawaitable_list = PyList_New(1);
        if (pyawaitable_list == NULL) {
            // Memory error
            return -1;
        }

        if (
            PyDict_SetItemString(
                interp_dict,
                "_pyawaitable_states",
                pyawaitable_list
            ) < 0
        ) {
            Py_DECREF(pyawaitable_list);
            return -1;
        }
    }

    if (PyList_Append(pyawaitable_list, state) < 0) {
        Py_DECREF(pyawaitable_list);
        return -1;
    }

    Py_DECREF(pyawaitable_list);
    return 0;
}

_PyAwaitable_API(int)
PyAwaitable_Init(void)
{
    PyObject *dict = __PyAwaitable_Static_interp_get_dict();
    if (dict == NULL) {
        return -1;
    }

    PyObject *state = __PyAwaitable_Static_create_state();
    if (state == NULL) {
        return -1;
    }

    PyObject *existing = PyDict_GetItemString(dict, "_pyawaitable_state");
    if (existing != NULL) {
        /* Oh no, PyAwaitable has been used twice! */
        long version = __PyAwaitable_Static_get_state_version(existing);
        if (version == -1) {
            Py_DECREF(state);
            return -1;
        }

        if (version == PyAwaitable_MAGIC_NUMBER) {
            // Yay! It just happens that it's the same version as us.
            // Let's just reuse it.
            Py_DECREF(state);
            return 0;
        }

        if (__PyAwaitable_Static_add_state_to_list(dict, state) < 0) {
            Py_DECREF(state);
            return -1;
        }

        Py_DECREF(state);
        return 0;
    }

    if (PyDict_SetItemString(dict, "_pyawaitable_state", state) < 0) {
        Py_DECREF(state);
        return -1;
    }

    Py_DECREF(state);
    return 0;
}

#undef CLEAR_CALLBACK_IF_CANCELLED
#undef SAVE
#undef DONE_IF_OK_AND_CHECK
#undef DONE
#undef SET
#undef FIRE_ERROR_CALLBACK_AND_NEXT
#undef DONE_IF_OK
#undef NOTHING
#undef GET
#undef AW_DONE
#undef RETURN_ADVANCE_GENERATOR
#undef CLEAR_IF_NON_NULL
#undef UNPACK
#else
#error "the limited API cannot be used with pyawaitable"
#endif /* PYAWAITABLE_VENDOR_H */
