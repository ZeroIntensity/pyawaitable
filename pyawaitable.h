
/* Autogenerated distribution copy of PyAwaitable 1.3.0 */

#define _PYAWAITABLE_VENDOR

#ifndef PYAWAITABLE_VENDOR_H
#define PYAWAITABLE_VENDOR_H
#include <stdbool.h>
#include <Python.h>
#include <stdlib.h>
#include <stdarg.h>
#ifndef PYAWAITABLE_DIST_H
#define PYAWAITABLE_DIST_H

#ifdef Py_LIMITED_API
#error "the limited API cannot be used with pyawaitable"
#endif

#ifdef _PYAWAITABLE_VENDOR
#define _PyAwaitable_API(ret) static ret
#define _PyAwaitable_INTERNAL(ret) static ret
#else
#define _PyAwaitable_API(ret) ret
#define _PyAwaitable_INTERNAL(ret) ret
#endif

#define _PyAwaitable_MANGLE(name) name
#define _PyAwaitable_NO_MANGLE(name) name

#define PyAwaitable_MAJOR_VERSION 2
#define PyAwaitable_MINOR_VERSION 0
#define PyAwaitable_MICRO_VERSION 0
#define PyAwaitable_PATCH_VERSION PyAwaitable_MINOR_VERSION

#endif

#ifndef PYAWAITABLE_ARRAY_H
#define PYAWAITABLE_ARRAY_H


#define ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE 16

/*
 * Deallocator for items on a __PyAwaitable_Mangled_pyawaitable_array structure. A NULL pointer
 * will never be given to the deallocator.
 */
typedef void (*_PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_array_deallocator))(void *);

/*
 * Internal only dynamic array for CPython.
 */
typedef struct
{
    /*
     * The actual items in the dynamic array.
     * Don't access this field publicly to get
     * items--use __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM() instead.
     */
    void **items;
    /*
     * The length of the actual items array allocation.
     */
    Py_ssize_t capacity;
    /*
     * The number of items in the array.
     * Don't use this field publicly--use __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH()
     */
    Py_ssize_t length;
    /*
     * The deallocator, set by one of the initializer functions.
     * This may be NULL.
     */
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_array);


/* Zero out the array */
static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ZERO(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    array->deallocator = NULL;
    array->items = NULL;
    array->length = 0;
    array->capacity = 0;
}

static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    assert(array->items != NULL);
}

static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    // Ensure the index is valid
    assert(index < array->length);
    assert(index >= 0);
}

/*
 * Initialize a dynamic array with an initial size and deallocator.
 *
 * If the deallocator is NULL, then nothing happens to items upon
 * removal and upon array clearing.
 *
 * Returns -1 upon failure, 0 otherwise.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_init_with_size(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
);

/*
 * Append to the array.
 *
 * Returns -1 upon failure, 0 otherwise.
 * If this fails, the deallocator is not ran on the item.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(__PyAwaitable_Mangled_pyawaitable_array * array, void *item);

/*
 * Insert an item at the target index. The index
 * must currently be a valid index in the array.
 *
 * Returns -1 upon failure, 0 otherwise.
 * If this fails, the deallocator is not ran on the item.
 */
_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_insert(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    Py_ssize_t index,
    void *item
);

/* Remove all items from the array. */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(__PyAwaitable_Mangled_pyawaitable_array * array);

/*
 * Clear all the fields on the array.
 *
 * Note that this does *not* free the actual dynamic array
 * structure--use __PyAwaitable_Mangled_pyawaitable_array_Free() for that.
 *
 * It's safe to call __PyAwaitable_Mangled_pyawaitable_array_init() or init_with_size() again
 * on the array after calling this.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(__PyAwaitable_Mangled_pyawaitable_array * array);

/*
 * Set a value at index in the array.
 *
 * If an item already exists at the target index, the deallocator
 * is called on it, if the array has one set.
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index, void *item);

/*
 * Remove the item at the index, and call the deallocator on it (if the array
 * has one set).
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_remove(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index);

/*
 * Remove the item at the index *without* deallocating it, and
 * return the item.
 *
 * This cannot fail.
 */
_PyAwaitable_INTERNAL(void *)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index);

/*
 * Clear all the fields on a dynamic array, and then
 * free the dynamic array structure itself.
 *
 * The array must have been created by __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new()
 */
static inline void
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(array);
    PyMem_RawFree(array);
}

/*
 * Equivalent to __PyAwaitable_Mangled_pyawaitable_array_init_with_size() with a default size of 16.
 *
 * Returns -1 upon failure, 0 otherwise.
 */
static inline int
__PyAwaitable_Mangled_pyawaitable_array_init(
    __PyAwaitable_Mangled_pyawaitable_array *array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator
)
{
    return __PyAwaitable_Mangled_pyawaitable_array_init_with_size(
        array,
        deallocator,
        ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE
    );
}

/*
 * Allocate and create a new dynamic array on the heap.
 *
 * The returned pointer should be freed with __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free()
 * If this function fails, it returns NULL.
 */
static inline __PyAwaitable_Mangled_pyawaitable_array *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size(
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
)
{
    __PyAwaitable_Mangled_pyawaitable_array *array = PyMem_Malloc(sizeof(__PyAwaitable_Mangled_pyawaitable_array));
    if (array == NULL)
    {
        return NULL;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init_with_size(array, deallocator, initial) < 0)
    {
        PyMem_Free(array);
        return NULL;
    }

    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array); // Sanity check
    return array;
}

/*
 * Equivalent to __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size() with a size of 16.
 *
 * The returned array must be freed with __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_free().
 * Returns NULL on failure.
 */
static inline __PyAwaitable_Mangled_pyawaitable_array *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new(__PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator)
{
    return __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_new_with_size(
        deallocator,
        ___PyAwaitable_Mangled_pyawaitable_array_DEFAULT_SIZE
    );
}

/*
 * Get an item from the array. This cannot fail.
 *
 * If the index is not valid, this is undefined behavior.
 */
static inline void *
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    return array->items[index];
}

/*
 * Get the length of the array. This cannot fail.
 */
static inline Py_ssize_t
__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    return array->length;
}

/*
 * Pop the item at the end the array.
 * This function cannot fail.
 */
static inline void *
__PyAwaitable_Static___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop_top(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    return __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(array, __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array) - 1);
}

#endif

#ifndef PYAWAITABLE_BACKPORT_H
#define PYAWAITABLE_BACKPORT_H


#if PY_VERSION_HEX < 0x030c0000
static PyObject *
_PyAwaitable_NO_MANGLE(PyErr_GetRaisedException)(void)
{
    PyObject *type, *val, *tb;
    PyErr_Fetch(&type, &val, &tb);
    PyErr_NormalizeException(&type, &val, &tb);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    // technically some entry in the traceback might be lost; ignore that
    return val;
}

static void
_PyAwaitable_NO_MANGLE(PyErr_SetRaisedException)(PyObject *err)
{
    // NOTE: We need to incref the type object here, even though
    // this function steals a reference to err.
    PyErr_Restore(Py_NewRef((PyObject *) Py_TYPE(err)), err, NULL);
}
#endif

#ifndef Py_NewRef
static inline PyObject *
_PyAwaitable_NO_MANGLE(Py_NewRef)(PyObject *o)
{
    Py_INCREF(o);
    return o;
}

#endif

#ifndef Py_XNewRef
static inline PyObject *
_PyAwaitable_NO_MANGLE(Py_XNewRef)(PyObject *o)
{
    Py_XINCREF(o);
    return o;
}
#endif

#endif

#ifndef PYAWAITABLE_CORO_H
#define PYAWAITABLE_CORO_H


extern PyMethodDef _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_methods)[];
extern PyAsyncMethods _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_async_methods);

#endif

#ifndef PYAWAITABLE_AWAITABLE_H
#define PYAWAITABLE_AWAITABLE_H



typedef int (*awaitcallback)(PyObject *, PyObject *);
typedef int (*awaitcallback_err)(PyObject *, PyObject *);

typedef struct ___PyAwaitable_Mangled_pyawaitable_callback
{
    PyObject *coro;
    awaitcallback callback;
    awaitcallback_err err_callback;
    bool done;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_pyawaitable_callback);

struct _PyAwaitableObject
{
    PyObject_HEAD

    __PyAwaitable_Mangled_pyawaitable_array aw_callbacks;
    __PyAwaitable_Mangled_pyawaitable_array aw_object_values;
    __PyAwaitable_Mangled_pyawaitable_array aw_arbitrary_values;
    __PyAwaitable_Mangled_pyawaitable_array aw_integer_values;

    /* Index of current callback */
    Py_ssize_t aw_state;
    /* Is the awaitable done? */
    bool aw_done;
    /* Was the awaitable awaited? */
    bool aw_awaited;
    /* Strong reference to the result of the coroutine. */
    PyObject *aw_result;
    /* Strong reference to the genwrapper. */
    PyObject *aw_gen;
    /* Set to 1 if the object was cancelled, for introspection against callbacks */
    int aw_recently_cancelled;
};

typedef struct _PyAwaitableObject PyAwaitableObject;
PyTypeObject PyAwaitableType;

_PyAwaitable_API(int)
pyawaitable_set_result(PyObject * awaitable, PyObject * result);

_PyAwaitable_API(int)
pyawaitable_await(
    PyObject * aw,
    PyObject * coro,
    awaitcallback cb,
    awaitcallback_err err
);

_PyAwaitable_API(void)
pyawaitable_cancel(PyObject * aw);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_awaitable_next(PyObject * self);

_PyAwaitable_API(PyObject *)
pyawaitable_new(void);

_PyAwaitable_API(int)
pyawaitable_await_function(
    PyObject * awaitable,
    PyObject * func,
    const char *fmt,
    awaitcallback cb,
    awaitcallback_err err,
    ...
);

#endif

#ifndef PYAWAITABLE_GENWRAPPER_H
#define PYAWAITABLE_GENWRAPPER_H


PyTypeObject _PyAwaitable_MANGLE(__PyAwaitable_Mangled__PyAwaitableGenWrapperType);

typedef struct ___PyAwaitable_Mangled_GenWrapperObject
{
    PyObject_HEAD
    PyAwaitableObject *gw_aw;
    PyObject *gw_current_await;
} _PyAwaitable_MANGLE(__PyAwaitable_Mangled_GenWrapperObject);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_next(PyObject * self);

_PyAwaitable_INTERNAL(int)
genwrapper_fire_err_callback(
    PyObject * self,
    awaitcallback_err err_callback
);

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_new(PyAwaitableObject * aw);

#endif

#ifndef PYAWAITABLE_VALUES_H
#define PYAWAITABLE_VALUES_H


#define SAVE(name) int name(PyObject * awaitable, Py_ssize_t nargs, ...)
#define UNPACK(name) int name(PyObject * awaitable, ...)
#define SET(name, tp)     \
        int name(         \
    PyObject * awaitable, \
    Py_ssize_t index,     \
    tp new_value          \
        )
#define GET(name, tp)     \
        tp name(          \
    PyObject * awaitable, \
    Py_ssize_t index      \
        )

// Normal values

SAVE(pyawaitable_save);
UNPACK(pyawaitable_unpack);
SET(pyawaitable_set, PyObject *);
GET(pyawaitable_get, PyObject *);

// Arbitrary values

SAVE(pyawaitable_save_arb);
UNPACK(pyawaitable_unpack_arb);
SET(pyawaitable_set_arb, void *);
GET(pyawaitable_get_arb, void *);

// Integer values

SAVE(pyawaitable_save_int);
UNPACK(pyawaitable_unpack_int);
SET(pyawaitable_set_int, long);
GET(pyawaitable_get_int, long);

#undef SAVE
#undef UNPACK
#undef GET
#undef SET

#endif

#ifndef PYAWAITABLE_WITH_H
#define PYAWAITABLE_WITH_H


_PyAwaitable_API(int)
pyawaitable_async_with(
    PyObject *aw,
    PyObject *ctx,
    awaitcallback cb,
    awaitcallback_err err
);

#endif


static int
__PyAwaitable_Static_async_with_inner(PyObject *aw, PyObject *res)
{
    awaitcallback cb;
    awaitcallback_err err;
    PyObject *exit;
    if (pyawaitable_unpack_arb(aw, &cb, &err) < 0)
        return -1;

    if (pyawaitable_unpack(aw, &exit) < 0)
        return -1;

    Py_INCREF(aw);
    Py_INCREF(res);
    int callback_result = cb != NULL ? cb(aw, res) : 0;
    Py_DECREF(res);
    Py_DECREF(aw);

    if (callback_result < 0)
    {
        PyObject *tp, *val, *tb;
        PyErr_Fetch(&tp, &val, &tb);
        PyErr_NormalizeException(&tp, &val, &tb);

        if (tp == NULL)
        {
            PyErr_SetString(
                PyExc_SystemError,
                "pyawaitable: async with callback returned -1 without exception set"
            );
            return -1;
        }

        // Traceback can still be NULL
        if (tb == NULL)
            tb = Py_NewRef(Py_None);

        PyObject *coro = PyObject_Vectorcall(
            exit,
            (PyObject *[]) { tp, val, tb },
            3,
            NULL
        );
        Py_DECREF(tp);
        Py_DECREF(val);
        Py_DECREF(tb);
        if (coro == NULL)
        {
            return -1;
        }

        if (pyawaitable_await(aw, coro, NULL, NULL) < 0)
        {
            Py_DECREF(coro);
            return -1;
        }

        Py_DECREF(coro);
        return 0;
    } else
    {
        // OK
        PyObject *coro = PyObject_Vectorcall(
            exit,
            (PyObject *[]) { Py_None, Py_None, Py_None },
            3,
            NULL
        );
        if (coro == NULL)
        {
            return -1;
        }

        if (pyawaitable_await(aw, coro, NULL, NULL) < 0)
        {
            Py_DECREF(coro);
            return -1;
        }
        Py_DECREF(coro);
        return 0;
    }
}

_PyAwaitable_API(int)
pyawaitable_async_with(
    PyObject *aw,
    PyObject *ctx,
    awaitcallback cb,
    awaitcallback_err err
)
{
    PyObject *with = PyObject_GetAttrString(ctx, "__aenter__");
    if (with == NULL)
    {
        PyErr_Format(
            PyExc_TypeError,
            "pyawaitable: %R is not an async context manager (missing __aenter__)",
            ctx
        );
        return -1;
    }
    PyObject *exit = PyObject_GetAttrString(ctx, "__aexit__");
    if (exit == NULL)
    {
        Py_DECREF(with);
        PyErr_Format(
            PyExc_TypeError,
            "pyawaitable: %R is not an async context manager (missing __aexit__)",
            ctx
        );
        return -1;
    }

    PyObject *inner_aw = pyawaitable_new();

    if (inner_aw == NULL)
    {
        Py_DECREF(with);
        Py_DECREF(exit);
        return -1;
    }

    if (pyawaitable_save_arb(inner_aw, 2, cb, err) < 0)
    {
        Py_DECREF(inner_aw);
        Py_DECREF(with);
        Py_DECREF(exit);
        return -1;
    }

    if (pyawaitable_save(inner_aw, 1, exit) < 0)
    {
        Py_DECREF(inner_aw);
        Py_DECREF(exit);
        Py_DECREF(with);
        return -1;
    }

    Py_DECREF(exit);

    PyObject *coro = PyObject_CallNoArgs(with);
    Py_DECREF(with);

    if (coro == NULL)
    {
        Py_DECREF(inner_aw);
        return -1;
    }

    // Note: Errors in __aenter__ are not sent to __aexit__
    if (
        pyawaitable_await(
            inner_aw,
            coro,
            __PyAwaitable_Static_async_with_inner,
            NULL
        ) < 0
    )
    {
        Py_DECREF(inner_aw);
        Py_DECREF(coro);
        return -1;
    }

    Py_DECREF(coro);

    if (pyawaitable_await(aw, inner_aw, NULL, err) < 0)
    {
        Py_DECREF(inner_aw);
        return -1;
    }

    Py_DECREF(inner_aw);
    return 0;
}


static inline void
__PyAwaitable_Static_call_deallocator_maybe(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    if (array->deallocator != NULL && array->items[index] != NULL)
    {
        array->deallocator(array->items[index]);
        array->items[index] = NULL;
    }
}

_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_init_with_size(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    __PyAwaitable_Mangled_pyawaitable_array_deallocator deallocator,
    Py_ssize_t initial
)
{
    assert(array != NULL);
    assert(initial > 0);
    void **items = PyMem_Calloc(sizeof(void *), initial);
    if (items == NULL)
    {
        return -1;
    }

    array->capacity = initial;
    array->items = items;
    array->length = 0;
    array->deallocator = deallocator;

    return 0;
}

static int
__PyAwaitable_Static_resize_if_needed(__PyAwaitable_Mangled_pyawaitable_array *array)
{
    if (array->length == array->capacity)
    {
        // Need to resize
        array->capacity *= 2;
        void **new_items = PyMem_Realloc(
            array->items,
            sizeof(void *) * array->capacity
        );
        if (new_items == NULL)
        {
            return -1;
        }

        array->items = new_items;
    }

    return 0;
}

_PyAwaitable_INTERNAL(int)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(__PyAwaitable_Mangled_pyawaitable_array * array, void *item)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    array->items[array->length++] = item;
    if (__PyAwaitable_Static_resize_if_needed(array) < 0)
    {
        array->items[--array->length] = NULL;
        return -1;
    }
    return 0;
}

_PyAwaitable_INTERNAL(int)
__PyAwaitable_Mangled_pyawaitable_array_insert(
    __PyAwaitable_Mangled_pyawaitable_array * array,
    Py_ssize_t index,
    void *item
)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    ++array->length;
    if (__PyAwaitable_Static_resize_if_needed(array) < 0)
    {
        // Grow the array beforehand, otherwise it's
        // going to be a mess putting it back together if
        // allocation fails.
        --array->length;
        return -1;
    }

    for (Py_ssize_t i = array->length - 1; i > index; --i)
    {
        array->items[i] = array->items[i - 1];
    }

    array->items[index] = item;
    return 0;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index, void *item)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    __PyAwaitable_Static_call_deallocator_maybe(array, index);
    array->items[index] = item;
}

static void
__PyAwaitable_Static_remove_no_dealloc(__PyAwaitable_Mangled_pyawaitable_array *array, Py_ssize_t index)
{
    for (Py_ssize_t i = index; i < array->length - 1; ++i)
    {
        array->items[i] = array->items[i + 1];
    }
    --array->length;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_remove(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    __PyAwaitable_Static_call_deallocator_maybe(array, index);
    __PyAwaitable_Static_remove_no_dealloc(array, index);
}

_PyAwaitable_INTERNAL(void *)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_pop(__PyAwaitable_Mangled_pyawaitable_array * array, Py_ssize_t index)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_INDEX(array, index);
    void *item = array->items[index];
    __PyAwaitable_Static_remove_no_dealloc(array, index);
    return item;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(__PyAwaitable_Mangled_pyawaitable_array * array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    for (Py_ssize_t i = 0; i < array->length; ++i)
    {
        __PyAwaitable_Static_call_deallocator_maybe(array, i);
        array->items[i] = NULL;
    }

    array->length = 0;
}

_PyAwaitable_INTERNAL(void)
__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(__PyAwaitable_Mangled_pyawaitable_array * array)
{
    __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_ASSERT_VALID(array);
    __PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(array);
    PyMem_Free(array->items);

    // It would be nice if others could reuse the allocation for another
    // dynarray later, so clear all the fields.
    array->items = NULL;
    array->length = 0;
    array->capacity = 0;
    array->deallocator = NULL;
}



PyDoc_STRVAR(
    awaitable_doc,
    "Awaitable transport utility for the C API."
);

static void
__PyAwaitable_Static_callback_dealloc(void *ptr)
{
    assert(ptr != NULL);
    __PyAwaitable_Mangled_pyawaitable_callback *cb = (__PyAwaitable_Mangled_pyawaitable_callback *) ptr;
    Py_CLEAR(cb->coro);
    PyMem_Free(cb);
}

static PyObject *
__PyAwaitable_Static_awaitable_new_func(PyTypeObject *tp, PyObject *args, PyObject *kwds)
{
    assert(tp != NULL);
    assert(tp->tp_alloc != NULL);

    PyObject *self = tp->tp_alloc(tp, 0);
    if (self == NULL)
    {
        return NULL;
    }

    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    aw->aw_gen = NULL;
    aw->aw_done = false;
    aw->aw_state = 0;
    aw->aw_result = NULL;
    aw->aw_recently_cancelled = 0;

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_callbacks, __PyAwaitable_Static_callback_dealloc) < 0)
    {
        goto error;
    }

    if (
        __PyAwaitable_Mangled_pyawaitable_array_init(
            &aw->aw_object_values,
            (__PyAwaitable_Mangled_pyawaitable_array_deallocator) Py_DecRef
        ) < 0
    )
    {
        goto error;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_arbitrary_values, NULL) < 0)
    {
        goto error;
    }

    if (__PyAwaitable_Mangled_pyawaitable_array_init(&aw->aw_integer_values, NULL) < 0)
    {
        goto error;
    }

    return self;
error:
    PyErr_NoMemory();
    Py_DECREF(self);
    return NULL;
}

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_awaitable_next(PyObject * self)
{
    PyAwaitableObject *aw = (PyAwaitableObject *)self;
    if (aw->aw_awaited)
    {
        PyErr_SetString(
            PyExc_RuntimeError,
            "pyawaitable: cannot reuse awaitable"
        );
        return NULL;
    }
    aw->aw_awaited = true;
    PyObject *gen = __PyAwaitable_Internal_genwrapper_new(aw);
    aw->aw_gen = Py_XNewRef(gen);
    return gen;
}

static void
__PyAwaitable_Static_awaitable_dealloc(PyObject *self)
{
    PyAwaitableObject *aw = (PyAwaitableObject *)self;
#define CLEAR_IF_NON_NULL(array)             \
        if (array.items != NULL) {           \
            __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear(&array); \
        }
    CLEAR_IF_NON_NULL(aw->aw_callbacks);
    CLEAR_IF_NON_NULL(aw->aw_object_values);
    CLEAR_IF_NON_NULL(aw->aw_arbitrary_values);
    CLEAR_IF_NON_NULL(aw->aw_integer_values);
#undef CLEAR_IF_NON_NULL

    Py_XDECREF(aw->aw_gen);
    Py_XDECREF(aw->aw_result);

    if (!aw->aw_done)
    {
        if (
            PyErr_WarnEx(
                PyExc_RuntimeWarning,
                "pyawaitable object was never awaited",
                1
            ) < 0
        )
        {
            PyErr_WriteUnraisable(self);
        }
    }

    Py_TYPE(self)->tp_free(self);
}

_PyAwaitable_API(void)
pyawaitable_cancel(PyObject * self)
{
    assert(self != NULL);
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    __PyAwaitable_Internal___PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_clear_items(&aw->aw_callbacks);
    aw->aw_state = 0;
    if (aw->aw_gen != NULL)
    {
        __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *)aw->aw_gen;
        Py_CLEAR(gw->gw_current_await);
    }

    aw->aw_recently_cancelled = 1;
}

_PyAwaitable_API(int)
pyawaitable_await(
    PyObject * self,
    PyObject * coro,
    awaitcallback cb,
    awaitcallback_err err
)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) self;

    __PyAwaitable_Mangled_pyawaitable_callback *aw_c = PyMem_Malloc(sizeof(__PyAwaitable_Mangled_pyawaitable_callback));
    if (aw_c == NULL)
    {
        PyErr_NoMemory();
        return -1;
    }

    aw_c->coro = Py_NewRef(coro);
    aw_c->callback = cb;
    aw_c->err_callback = err;
    aw_c->done = false;

    if (__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(&aw->aw_callbacks, aw_c) < 0)
    {
        PyMem_Free(aw_c);
        PyErr_NoMemory();
        return -1;
    }

    return 0;
}

_PyAwaitable_API(int)
pyawaitable_set_result(PyObject * awaitable, PyObject * result)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;
    aw->aw_result = Py_NewRef(result);
    return 0;
}

_PyAwaitable_API(PyObject *)
pyawaitable_new(void)
{
    // XXX Use a freelist?
    return __PyAwaitable_Static_awaitable_new_func(&PyAwaitableType, NULL, NULL);
}

_PyAwaitable_API(int)
pyawaitable_await_function(
    PyObject * awaitable,
    PyObject * func,
    const char *fmt,
    awaitcallback cb,
    awaitcallback_err err,
    ...
)
{
    size_t len = strlen(fmt);
    size_t size = len + 3;
    char *tup_format = PyMem_Malloc(size);
    if (!tup_format)
    {
        PyErr_NoMemory();
        return -1;
    }

    tup_format[0] = '(';
    for (size_t i = 0; i < len; ++i)
    {
        tup_format[i + 1] = fmt[i];
    }

    tup_format[size - 2] = ')';
    tup_format[size - 1] = '\0';

    va_list vargs;
    va_start(vargs, err);
    PyObject *args = Py_VaBuildValue(tup_format, vargs);
    va_end(vargs);
    PyMem_Free(tup_format);

    if (!args)
        return -1;
    PyObject *coro = PyObject_Call(func, args, NULL);
    Py_DECREF(args);

    if (!coro)
        return -1;

    if (pyawaitable_await(awaitable, coro, cb, err) < 0)
    {
        Py_DECREF(coro);
        return -1;
    }

    Py_DECREF(coro);
    return 0;
}

PyTypeObject PyAwaitableType =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_PyAwaitableType",
    .tp_basicsize = sizeof(PyAwaitableObject),
    .tp_dealloc = __PyAwaitable_Static_awaitable_dealloc,
    .tp_as_async = &__PyAwaitable_Mangled_pyawaitable_async_methods,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_doc = awaitable_doc,
    .tp_iternext = __PyAwaitable_Internal_awaitable_next,
    .tp_new = __PyAwaitable_Static_awaitable_new_func,
    .tp_methods = __PyAwaitable_Mangled_pyawaitable_methods
};


static PyObject *
__PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(PyObject *self, PyObject *value)
{
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    if (aw->aw_gen == NULL)
    {
        PyObject *gen = __PyAwaitable_Internal_awaitable_next(self);
        if (gen == NULL)
        {
            return NULL;
        }

        Py_DECREF(gen);
        Py_RETURN_NONE;
    }

    return __PyAwaitable_Internal_genwrapper_next(aw->aw_gen);
}

static PyObject *
__PyAwaitable_Static_awaitable_send(PyObject *self, PyObject *args)
{
    PyObject *value;

    if (!PyArg_ParseTuple(args, "O", &value))
    {
        return NULL;
    }

    return __PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(self, value);
}

static PyObject *
__PyAwaitable_Static_awaitable_close(PyObject *self, PyObject *args)
{
    pyawaitable_cancel(self);
    PyAwaitableObject *aw = (PyAwaitableObject *) self;
    aw->aw_done = true;
    Py_RETURN_NONE;
}

static PyObject *
__PyAwaitable_Static_awaitable_throw(PyObject *self, PyObject *args)
{
    PyObject *type;
    PyObject *value = NULL;
    PyObject *traceback = NULL;

    if (!PyArg_ParseTuple(args, "O|OO", &type, &value, &traceback))
    {
        return NULL;
    }

    if (PyType_Check(type))
    {
        PyObject *err = PyObject_CallOneArg(type, value);
        if (err == NULL)
        {
            return NULL;
        }

        if (traceback)
        {
            if (PyException_SetTraceback(err, traceback) < 0)
            {
                Py_DECREF(err);
                return NULL;
            }
        }

        PyErr_Restore(err, NULL, NULL);
    } else
    {
        PyErr_Restore(
            Py_NewRef(type),
            Py_XNewRef(value),
            Py_XNewRef(traceback)
        );
    }

    PyAwaitableObject *aw = (PyAwaitableObject *)self;
    if ((aw->aw_gen != NULL) && (aw->aw_state != 0))
    {
        __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *)aw->aw_gen;
        __PyAwaitable_Mangled_pyawaitable_callback *cb =
            __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(&aw->aw_callbacks, aw->aw_state - 1);
        if (cb == NULL)
        {
            return NULL;
        }

        if (genwrapper_fire_err_callback(self, cb->err_callback) < 0)
        {
            return NULL;
        }
    } else
    {
        return NULL;
    }

    assert(PyErr_Occurred());
    return NULL;
}

#if PY_MINOR_VERSION > 9
static PySendResult
__PyAwaitable_Static_awaitable_am_send(PyObject *self, PyObject *arg, PyObject **presult)
{
    PyObject *send_res = __PyAwaitable_Static___PyAwaitable_Static_awaitable_send_with_arg(self, arg);
    if (send_res == NULL)
    {
        if (PyErr_ExceptionMatches(PyExc_StopIteration))
        {
            PyObject *occurred = PyErr_GetRaisedException();
            PyObject *item = PyObject_GetAttrString(occurred, "value");
            Py_DECREF(occurred);

            if (item == NULL)
            {
                return PYGEN_ERROR;
            }

            *presult = item;
            return PYGEN_RETURN;
        }
        *presult = NULL;
        return PYGEN_ERROR;
    }
    *presult = send_res;

    return PYGEN_NEXT;
}

#endif

PyMethodDef __PyAwaitable_Mangled_pyawaitable_methods[] =
{
    {"send", __PyAwaitable_Static_awaitable_send, METH_VARARGS, NULL},
    {"close", __PyAwaitable_Static_awaitable_close, METH_VARARGS, NULL},
    {"throw", __PyAwaitable_Static_awaitable_throw, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};

PyAsyncMethods __PyAwaitable_Mangled_pyawaitable_async_methods =
{
#if PY_MINOR_VERSION > 9
    .am_await = __PyAwaitable_Internal_awaitable_next,
    .am_send = __PyAwaitable_Static_awaitable_am_send
#else
    .am_await = __PyAwaitable_Internal_awaitable_next
#endif
};

#define DONE(cb)                 \
        do { cb->done = true;    \
             Py_CLEAR(cb->coro); \
             Py_CLEAR(g->gw_current_await); } while (0)
#define AW_DONE()               \
        do {                    \
            aw->aw_done = true; \
            Py_CLEAR(g->gw_aw); \
        } while (0)
#define DONE_IF_OK(cb)    \
        if (cb != NULL) { \
            DONE(cb);     \
        }

static PyObject *
__PyAwaitable_Static_gen_new(PyTypeObject *tp, PyObject *args, PyObject *kwds)
{
    assert(tp != NULL);
    assert(tp->tp_alloc != NULL);

    PyObject *self = tp->tp_alloc(tp, 0);
    if (self == NULL)
    {
        return NULL;
    }

    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    g->gw_aw = NULL;
    g->gw_current_await = NULL;

    return (PyObject *) g;
}

static int
__PyAwaitable_Static_genwrapper_traverse(PyObject *self, visitproc visit, void *arg)
{
    __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    Py_VISIT(gw->gw_current_await);
    Py_VISIT(gw->gw_aw);
    return 0;
}

static int
__PyAwaitable_Static_genwrapper_clear(PyObject *self)
{
    __PyAwaitable_Mangled_GenWrapperObject *gw = (__PyAwaitable_Mangled_GenWrapperObject *) self;
    Py_CLEAR(gw->gw_current_await);
    Py_CLEAR(gw->gw_aw);
    return 0;
}

static void
__PyAwaitable_Static_gen_dealloc(PyObject *self)
{
    PyObject_GC_UnTrack(self);
    (void)__PyAwaitable_Static_genwrapper_clear(self);
    Py_TYPE(self)->tp_free(self);
}

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_new(PyAwaitableObject *aw)
{
    assert(aw != NULL);
    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *) __PyAwaitable_Static_gen_new(
        &__PyAwaitable_Mangled__PyAwaitableGenWrapperType,
        NULL,
        NULL
    );

    if (!g)
        return NULL;

    g->gw_aw = (PyAwaitableObject *) Py_NewRef((PyObject *) aw);
    return (PyObject *) g;
}

_PyAwaitable_INTERNAL(int)
genwrapper_fire_err_callback(
    PyObject *self,
    awaitcallback_err err_callback
)
{
    assert(PyErr_Occurred() != NULL);
    if (err_callback == NULL)
    {
        return -1;
    }

    PyObject *err = PyErr_GetRaisedException();

    Py_INCREF(self);
    int e_res = err_callback(self, err);
    Py_DECREF(self);

    if (e_res < 0)
    {
        // If the res is -1, the error is restored.
        // Otherwise, it is not.
        if (e_res == -1)
        {
            PyErr_SetRaisedException(err);
        } else
        {
            Py_DECREF(err);
        }
        return -1;
    }

    Py_DECREF(err);
    return 0;
}

static inline __PyAwaitable_Mangled_pyawaitable_callback *
__PyAwaitable_Static_genwrapper_advance(__PyAwaitable_Mangled_GenWrapperObject *gw)
{
    return __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(
        &gw->gw_aw->aw_callbacks,
        gw->gw_aw->aw_state++
    );
}

_PyAwaitable_INTERNAL(PyObject *)
__PyAwaitable_Internal_genwrapper_next(PyObject *self)
{
    __PyAwaitable_Mangled_GenWrapperObject *g = (__PyAwaitable_Mangled_GenWrapperObject *)self;
    PyAwaitableObject *aw = g->gw_aw;

    if (!aw)
    {
        PyErr_SetString(
            PyExc_RuntimeError,
            "pyawaitable: genwrapper used after return"
        );
        return NULL;
    }

    __PyAwaitable_Mangled_pyawaitable_callback *cb;

    if (g->gw_current_await == NULL)
    {
        if (__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(&aw->aw_callbacks) == aw->aw_state)
        {
            PyErr_SetObject(
                PyExc_StopIteration,
                aw->aw_result ? aw->aw_result : Py_None
            );
            AW_DONE();
            return NULL;
        }

        cb = __PyAwaitable_Static_genwrapper_advance(g);
        assert(cb != NULL);
        assert(cb->done == false);
        assert(cb->coro != NULL);

        if (cb->coro == NULL)
        {
            printf(
                "len: %ld, state: %ld\n",
                __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(&aw->aw_callbacks),
                aw->aw_state
            );
        }

        if (
            Py_TYPE(cb->coro)->tp_as_async == NULL ||
            Py_TYPE(cb->coro)->tp_as_async->am_await == NULL
        )
        {
            PyErr_Format(
                PyExc_TypeError,
                "pyawaitable: %R is not awaitable",
                cb->coro
            );
            DONE(cb);
            AW_DONE();
            return NULL;
        }

        g->gw_current_await = Py_TYPE(cb->coro)->tp_as_async->am_await(
            cb->coro
        );
        if (g->gw_current_await == NULL)
        {
            if (
                genwrapper_fire_err_callback(
                    (PyObject *)aw,
                    cb->err_callback
                ) < 0
            )
            {
                DONE_IF_OK(cb);
                AW_DONE();
                return NULL;
            }

            DONE_IF_OK(cb);
            return __PyAwaitable_Internal_genwrapper_next(self);
        }
    } else
    {
        cb = __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(&aw->aw_callbacks, aw->aw_state - 1);
    }

    PyObject *result = Py_TYPE(
        g->gw_current_await
    )->tp_iternext(g->gw_current_await);

    if (result != NULL)
    {
        // Yield!
        return result;
    }

    PyObject *occurred = PyErr_Occurred();
    if (!occurred)
    {
        // Coro is done, no result.
        if (!cb->callback)
        {
            // No callback, skip that step.
            DONE(cb);
            return __PyAwaitable_Internal_genwrapper_next(self);
        }
    }

    // TODO: I wonder if the occurred check is needed here.
    if (
        occurred && !PyErr_ExceptionMatches(PyExc_StopIteration)
    )
    {
        if (
            genwrapper_fire_err_callback(
                (PyObject *) aw,
                cb->err_callback
            ) < 0
        )
        {
            DONE(cb);
            AW_DONE();
            return NULL;
        }

        DONE(cb);
        return __PyAwaitable_Internal_genwrapper_next(self);
    }

    if (cb->callback == NULL)
    {
        // Coroutine is done, but with a result.
        // We can disregard the result if theres no callback.
        DONE(cb);
        PyErr_Clear();
        return __PyAwaitable_Internal_genwrapper_next(self);
    }

    // Deduce the return value of the coroutine
    PyObject *value;
    if (occurred)
    {
        value = PyErr_GetRaisedException();
        assert(value != NULL);
        assert(PyObject_IsInstance(value, PyExc_StopIteration));
        PyObject *tmp = PyObject_GetAttrString(value, "value");
        if (tmp == NULL)
        {
            Py_DECREF(value);
            DONE(cb);
            AW_DONE();
            return NULL;
        }
        Py_DECREF(value);
        value = tmp;
    } else
    {
        value = Py_NewRef(Py_None);
    }

    // Preserve the error callback in case we get cancelled
    awaitcallback_err err_callback = cb->err_callback;
    Py_INCREF(aw);
    int res = cb->callback((PyObject *) aw, value);
    Py_DECREF(aw);
    Py_DECREF(value);

    // If we recently cancelled, then cb is no longer valid
    if (aw->aw_recently_cancelled)
    {
        cb = NULL;
    }

    if (res < -1)
    {
        // -2 or lower denotes that the error should be deferred,
        // regardless of whether a handler is present.
        DONE_IF_OK(cb);
        AW_DONE();
        return NULL;
    }

    if (res < 0)
    {
        if (!PyErr_Occurred())
        {
            PyErr_SetString(
                PyExc_RuntimeError,
                "pyawaitable: user callback returned -1 without exception set"
            );
            DONE(cb);
            AW_DONE();
            return NULL;
        }
        if (
            genwrapper_fire_err_callback(
                (PyObject *) aw,
                err_callback
            ) < 0
        )
        {
            DONE_IF_OK(cb);
            AW_DONE();
            return NULL;
        }
    }

    DONE_IF_OK(cb);
    return __PyAwaitable_Internal_genwrapper_next(self);
}

PyTypeObject _PyAwaitable_MANGLE(__PyAwaitable_Mangled__PyAwaitableGenWrapperType) =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_genwrapper",
    .tp_basicsize = sizeof(__PyAwaitable_Mangled_GenWrapperObject),
    .tp_dealloc = __PyAwaitable_Static_gen_dealloc,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    .tp_iter = PyObject_SelfIter,
    .tp_iternext = __PyAwaitable_Internal_genwrapper_next,
    .tp_clear = __PyAwaitable_Static_genwrapper_clear,
    .tp_traverse = __PyAwaitable_Static_genwrapper_traverse,
    .tp_new = __PyAwaitable_Static_gen_new,
};



#define NOTHING

#define SAVE(field, type, extra)                                    \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;    \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                      \
        va_list vargs;                                              \
        va_start(vargs, nargs);                                     \
        for (Py_ssize_t i = 0; i < nargs; ++i) {                    \
            type ptr = va_arg(vargs, type);                         \
            assert((void *)ptr != NULL);                            \
            if (__PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_append(array, (void *)ptr) < 0) { \
                PyErr_NoMemory();                                   \
                return -1;                                          \
            }                                                       \
            extra;                                                  \
        }                                                           \
        va_end(vargs);                                              \
        return 0

#define UNPACK(field, type)                                                \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;           \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                             \
        if (__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array) == 0) {                        \
            PyErr_SetString(                                               \
    PyExc_RuntimeError,                                                    \
    "pyawaitable: object has no stored values"                             \
            );                                                             \
            return -1;                                                     \
        }                                                                  \
        va_list vargs;                                                     \
        va_start(vargs, awaitable);                                        \
        for (Py_ssize_t i = 0; i < __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array); ++i) { \
            type *ptr = va_arg(vargs, type *);                             \
            if (ptr == NULL) {                                             \
                continue;                                                  \
            }                                                              \
            *ptr = (type)__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(array, i);             \
        }                                                                  \
        va_end(vargs);                                                     \
        return 0

#define SET(field, type)                                          \
        assert(awaitable != NULL);                                \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable;  \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                    \
        if (__PyAwaitable_Static_check_index(index, array) < 0) {                      \
            return -1;                                            \
        }                                                         \
        __PyAwaitable_Internal___PyAwaitable_Mangled_pyawaitable_array_set(array, index, (void *)(new_value)); \
        return 0

#define GET(field, type)                                         \
        assert(awaitable != NULL);                               \
        PyAwaitableObject *aw = (PyAwaitableObject *) awaitable; \
        __PyAwaitable_Mangled_pyawaitable_array *array = &aw->field;                   \
        if (__PyAwaitable_Static_check_index(index, array) < 0) {                     \
            return (type)NULL;                                   \
        }                                                        \
        return (type)__PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_GET_ITEM(array, index)

static int
__PyAwaitable_Static_check_index(Py_ssize_t index, __PyAwaitable_Mangled_pyawaitable_array *array)
{
    assert(array != NULL);
    if (index < 0)
    {
        PyErr_SetString(
            PyExc_IndexError,
            "pyawaitable: cannot set negative index"
        );
        return -1;
    }

    if (index >= __PyAwaitable_Static___PyAwaitable_Mangled_pyawaitable_array_LENGTH(array))
    {
        PyErr_SetString(
            PyExc_IndexError,
            "pyawaitable: cannot set index that is out of bounds"
        );
        return -1;
    }

    return 0;
}

int
pyawaitable_unpack(PyObject *awaitable, ...)
{
    UNPACK(aw_object_values, PyObject *);
}

int
pyawaitable_save(PyObject *awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_object_values, PyObject *, Py_INCREF(ptr));
}

int
pyawaitable_set(
    PyObject *awaitable,
    Py_ssize_t index,
    PyObject *new_value
)
{
    SET(aw_object_values, Py_NewRef);
}

PyObject *
pyawaitable_get(
    PyObject *awaitable,
    Py_ssize_t index
)
{
    GET(aw_object_values, PyObject *);
}

/* Arbitrary Values */

int
pyawaitable_unpack_arb(PyObject *awaitable, ...)
{
    UNPACK(aw_arbitrary_values, void *);
}

int
pyawaitable_save_arb(PyObject *awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_arbitrary_values, void *, NOTHING);
}

int
pyawaitable_set_arb(
    PyObject *awaitable,
    Py_ssize_t index,
    void *new_value
)
{
    SET(aw_arbitrary_values, void *);
}

void *
pyawaitable_get_arb(
    PyObject *awaitable,
    Py_ssize_t index
)
{
    GET(aw_arbitrary_values, void *);
}

/* Integer Values */

int
pyawaitable_unpack_int(PyObject *awaitable, ...)
{
    UNPACK(aw_integer_values, long);
}

int
pyawaitable_save_int(PyObject *awaitable, Py_ssize_t nargs, ...)
{
    SAVE(aw_integer_values, long, NOTHING);
}

int
pyawaitable_set_int(
    PyObject *awaitable,
    Py_ssize_t index,
    long new_value
)
{
    SET(aw_integer_values, long);
}

long
pyawaitable_get_int(
    PyObject *awaitable,
    Py_ssize_t index
)
{
    GET(aw_integer_values, long);
}

#endif /* PYAWAITABLE_VENDOR_H */
